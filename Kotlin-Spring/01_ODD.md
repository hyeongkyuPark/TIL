# 핵심요소

## 캡슐화

캡슐화는 객체의 속성을 보호하기 위해서 사용함

### Method 설계

- 속성이 선언되었으나, 이의 상태를 변경하는 method가 없다면, 잘못 선언된 속성임. 즉, 자신이 가지고 있는 속성에 대해서는 해당 상태를 변경하는 기능을 제공해야 함
- 실물 객체가 가진 기능을 모두 제공해야 함
- 각각의 method는 서로 관련성이 있어야 함
- 객체 안의 method는 객체 안의 속성을 처리해야 하며, 다른 객체를 전달받아 다른 객체의 속성을 직접 처리하면 안됨. 단, 다른 객체의 값을 전달 받아 처리가 필요한 경우에는 객체 자체를 전달 받는것이 아니라 속성을 반환하는 method를 활용하여 값만을 매개변수의 형태로 전달받아야 함

### Method 종류

- Getter / Setter : 외부에서 내부 속성에 직접 접근하는것이 아닌 Getter / Setter 를 통해 접근하도록 적용
- CRUD : 데이터 처리를 위한 기본적인 CRUD 제공
- Business Logic : 비즈니스 로직 처리를 위한 method 제공
- 객체의 생명주기 : destory(), disconnect() 등 소멸에 대한 method
- 객체의 영구성 관리: 유효성 속성에 대한 변경이 필요한 경우 외부에서는 접근이 불가능한 private로 선언하며, 내부의 다른 method를 통해서 사용 되도록 함

### 장점

- 객체지향의 패러다임 중 하나인 추상화를 제공함
    - 실제로 method가 어떻게 동작하는지는 외부에서 이해할 필요가 없음
- 재사용성 향상
    - 객체의 모듈성과 응집도가 높아져 이를 통해 재 사용성이 높아짐
    - 절차지향 프로그래밍에서는 함수가 참조하고 있는 전역변수 및 내부에서 호출하는 method가 미치는 영향을 모두 체크해야하지만, 객체의 경우는 단일 객체에만 영향을 주기 때문에 재사용성이 높음
- 유지보수의 효율성이 향상
- 주로 변수는 private로 선언하고 method를 public으로 선언하는 형태를 많이 가짐
    - 이는 객체의 무결성을 위함 ⇒ Getter / Setter 를 제외 한 public method는 입력된 매개변수를 validation 한 후 실행하는 것을 기본으로 함. 이를 통해 객체의 값을 바꾸거나 값의 대한 유효성을 가질 수 있음

## 상속

객체지향에서의 상속은 속성의 상속이 아닌 하위로 내려갈 수록 구체화 되는 것

```docker
유닛
지상 유닛, 공중 유닛 [유닛 상속]
저글링, 탱크 [지상 유닛 상속] 정찰기, 수송기 [공중 유닛 상속]
```

### 상속의 효과

- 프로그램 구조에 대한 이해도 향상. 최상위 클래스를 보고 하위 클래스의 동작을 이해 할 수 있음
- 재사용성 향상 : 새로은 클래스 추가시, 공통되는 속성 및 메서드를 모두 정의하지 않고, 상속 받아 사용 할 수 있음
- 확장성 향상 : 일괄된 형태의 클래스 객체를 추가 할 수 있어, 간단하게 프로그램 확장이 가능
- 유지보수성 향상

## 다형성

하나의 개체가 여러 개의 형태로 변화 하는것을 말하며, 이를 객체 지향에서도 유사하게 사용하고 있음 (오버라이딩을 통해서 가능)

*오버라이딩 : 이미 선언되어 있는 메서드를 덮어씀 (재정의)

```java
// 오버라이딩 X
public void unitMove(Unit unit) {
	if(unit == "탱크") {
		// ....
	} else if(unit == "저글링") {
		// ...
	} else if(...) {...}
}
// 오버라이딩 O
@Override
public void move() {
	// 각각의 move method를 만들어 줌
}
```

## 추상화

객체지향에서의 추상화는 모델링

구체적으로 공통적인 부분, 또는 특징 특성을 분리해서 재조합 하는 부분이 추상화(다형성과 상속 모두 추상화에 속함)

# SOLID 원칙

## 응집도와 결합도

좋은 소프트웨어 설계를 위해서는 결합도(coupling)는 낮추고 응집도(cohesion)는 높여햐 함

### 결합도

- 모듈(클래스)간의 상호 의존 정도를 나타내는 지표로써 결합도가 낮으면 모듈간의 상호 의존성이 줄어들어 객체의 재사용 및 유지보수가 유리함

### 응집도

- 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져, 재사용 및 유지보수가 용이함

## SRP(Single Reponsibility Principle) 단일 책임 원칙

어떠한 클래스를 변경해야 하는 이유는 한가지 뿐이어야 함

```java
// 한 클래스에서 여러가지 동작을 구현해 사용함
// 한 기능의 변경사항이 있을경우 불편함
public class FTPClient() {
	public File writer() {...}
	public File reader() {...}
	public Network connection() {...}
}

// 각각의 역할을 하는 클래스로 분리
// 기능이 변경되면 한 클래스 내부의 수정만이 필요함으로 유지보수가 편리함
public class FileWriter() {...}
public class FileReader() {...}
```

## OCP(Open Closed Principle) 개방 폐쇠 원칙

자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 함

상위 클래스 또는 인터페이스를 중간에 둠으로써, 자신은 변화에 대해서는 폐쇄적이지만, 인터페이스는 외부의 변화데 대해서 확장을 개방해 줄 수 있음 (JDBC, Hibernate 등)

### JDBC 인터페이스

- DB Driver를 Application에 직접 연결하는 것이 아니라, 중간에 JDBC 인터페이스를 두고 Application은 이 인터페이스와만 연결함으로써 사용하는 부분에서는 변화에 영향이 없고 내부적인 수정만 필요하도록 설계됨

## LSP(Liskov Substitution Principle) 리스코프 치환 원칙

서브 타입은 언제나 자신의 상위 타입으로 교체 할 수 있어야 함

## ISP(Interface Segregation Principle) 인터페이스 분리 원칙

클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안됨

프로젝트 요구 사항과 설계에 따라서 SRP / ISP를 선택

## DIP(Dependency Inversion Principle) 의존 역전 원칙

자신보다 변하기 쉬운 것에 의존하지 말아야 함

사람 ⇒ 여름옷, 가을옷, 겨울옷 (사람보다 옷의 종류들이 더 변하기 쉬움으로 의존하면 안됨)

사람 ⇒ 옷  <= 여름옷, 가울옷, 겨울옷 (옷 종류들이 옷에 의존하고 사람이 그 옷을 의존하도록 변경해야 함)

# POGO JAVA

## POJO

순수한 자바 오브텍트를 뜻함

과거에는 EJB가 인기를 끌고, 많이 사용하던 때에는 단순한 자바 오브젝트를 사용해서 개발하는 것이 아닌, EJB를 종속적인 부분으로 개발을 진행함 ⇒ 모듈의 교체, 시스템 업그레이드시 종속성으로 인한 불편함이 발생

### POJO 특징

- 특정 라이브러리, 모듈에서 정의된 클래스를 상속 받아서 구현하지 않아도 됨
- POJO가 되기 위해서는 외부의 의존성을 두지 않고, 순수한 JAVA로 구성이 가능해야 함
- 특정환경에 종속되지 않음
    - 만약 특정 비즈니스 로직을 처리하는 부분에 외부 종속적인 http request, session 등 POJO를 위배한 것으로 간주함
    - `@Annotation` 기반으로 설정하는 부분도 엄연히는 POJO라고 볼 수 없음
- Spring, Hibernate
    - 하나의 서비스를 개발하기 위해서는, 시스템의 복잡함, 비즈니스 로직의 복잡함 등 다양한 어려움을 맞이 하게됨
    - 위의 두 프레임워크는 객체지향적인 설계를 하고 있으며, 또한 POJO를 지향하고 있음
    - 개발자가 서비스 로직에 집중호가 이를 POJO로 쉽게 개발 할 수 있도록 지원하고 있음
